import { getDbForDomain } from '../../../core/db/app-db-router.js';
import { createChildLogger } from '../../../core/utils/logger.js';

const log = createChildLogger('harbor-vulnerability-store');

function db() { return getDbForDomain('harbor-vulnerabilities'); }

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export interface VulnerabilityRecord {
  id: number;
  cve_id: string;
  severity: string;
  cvss_v3_score: number | null;
  package: string;
  version: string;
  fixed_version: string | null;
  status: string | null;
  description: string | null;
  links: string | null;
  project_id: number;
  repository_name: string;
  digest: string;
  tags: string | null;
  in_use: boolean;
  matching_containers: string | null;
  synced_at: string;
}

export interface VulnerabilityInsert {
  cve_id: string;
  severity: string;
  cvss_v3_score: number | null;
  package: string;
  version: string;
  fixed_version: string | null;
  status: string | null;
  description: string | null;
  links: string | null;
  project_id: number;
  repository_name: string;
  digest: string;
  tags: string | null;
  in_use: boolean;
  matching_containers: string | null;
}

export interface ExceptionRecord {
  id: number;
  cve_id: string;
  scope: string;
  scope_ref: string | null;
  justification: string;
  created_by: string;
  approved_by: string | null;
  expires_at: string | null;
  is_active: boolean;
  synced_to_harbor: boolean;
  created_at: string;
  updated_at: string;
}

export interface SyncStatusRecord {
  id: number;
  sync_type: string;
  status: string;
  vulnerabilities_synced: number;
  in_use_matched: number;
  error_message: string | null;
  started_at: string;
  completed_at: string | null;
}

export interface VulnerabilitySummary {
  total: number;
  critical: number;
  high: number;
  medium: number;
  low: number;
  in_use_total: number;
  in_use_critical: number;
  fixable: number;
  excepted: number;
}

export interface GetVulnerabilitiesOptions {
  severity?: string;
  inUse?: boolean;
  cveId?: string;
  repositoryName?: string;
  limit?: number;
  offset?: number;
}

// ---------------------------------------------------------------------------
// Vulnerability CRUD
// ---------------------------------------------------------------------------

/** Clear all vulnerabilities and insert a fresh batch (used during full sync) */
export async function replaceAllVulnerabilities(vulns: VulnerabilityInsert[]): Promise<number> {
  return db().transaction(async (txDb) => {
    await txDb.execute('DELETE FROM harbor_vulnerabilities');

    let inserted = 0;
    for (const v of vulns) {
      await txDb.execute(
        `INSERT INTO harbor_vulnerabilities
         (cve_id, severity, cvss_v3_score, package, version, fixed_version, status, description, links, project_id, repository_name, digest, tags, in_use, matching_containers, synced_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())
         ON CONFLICT (cve_id, package, version, digest) DO UPDATE SET
           severity = excluded.severity,
           cvss_v3_score = excluded.cvss_v3_score,
           fixed_version = excluded.fixed_version,
           status = excluded.status,
           description = excluded.description,
           links = excluded.links,
           project_id = excluded.project_id,
           repository_name = excluded.repository_name,
           tags = excluded.tags,
           in_use = excluded.in_use,
           matching_containers = excluded.matching_containers,
           synced_at = NOW()`,
        [
          v.cve_id, v.severity, v.cvss_v3_score, v.package, v.version,
          v.fixed_version, v.status, v.description, v.links,
          v.project_id, v.repository_name, v.digest, v.tags,
          v.in_use, v.matching_containers,
        ],
      );
      inserted++;
    }

    log.info({ inserted }, 'Replaced all vulnerability records');
    return inserted;
  });
}

/** Query vulnerabilities with filtering */
export async function getVulnerabilities(
  options: GetVulnerabilitiesOptions = {},
): Promise<VulnerabilityRecord[]> {
  const conditions: string[] = [];
  const params: unknown[] = [];

  if (options.severity) {
    conditions.push('v.severity = ?');
    params.push(options.severity);
  }
  if (options.inUse !== undefined) {
    conditions.push('v.in_use = ?');
    params.push(options.inUse);
  }
  if (options.cveId) {
    conditions.push('v.cve_id = ?');
    params.push(options.cveId);
  }
  if (options.repositoryName) {
    conditions.push('v.repository_name ILIKE ?');
    params.push(`%${options.repositoryName}%`);
  }

  const where = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
  const limit = options.limit ?? 200;
  const offset = options.offset ?? 0;

  return db().query<VulnerabilityRecord>(
    `SELECT v.* FROM harbor_vulnerabilities v
     ${where}
     ORDER BY
       CASE v.severity
         WHEN 'Critical' THEN 0
         WHEN 'High' THEN 1
         WHEN 'Medium' THEN 2
         WHEN 'Low' THEN 3
         ELSE 4
       END,
       v.in_use DESC,
       v.cvss_v3_score DESC NULLS LAST
     LIMIT ? OFFSET ?`,
    [...params, limit, offset],
  );
}

/** Get vulnerability summary statistics */
export async function getVulnerabilitySummary(): Promise<VulnerabilitySummary> {
  const row = await db().queryOne<{
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    in_use_total: number;
    in_use_critical: number;
    fixable: number;
  }>(`
    SELECT
      COUNT(*)::integer as total,
      SUM(CASE WHEN severity = 'Critical' THEN 1 ELSE 0 END)::integer as critical,
      SUM(CASE WHEN severity = 'High' THEN 1 ELSE 0 END)::integer as high,
      SUM(CASE WHEN severity = 'Medium' THEN 1 ELSE 0 END)::integer as medium,
      SUM(CASE WHEN severity = 'Low' THEN 1 ELSE 0 END)::integer as low,
      SUM(CASE WHEN in_use = true THEN 1 ELSE 0 END)::integer as in_use_total,
      SUM(CASE WHEN in_use = true AND severity = 'Critical' THEN 1 ELSE 0 END)::integer as in_use_critical,
      SUM(CASE WHEN fixed_version IS NOT NULL AND fixed_version != '' THEN 1 ELSE 0 END)::integer as fixable
    FROM harbor_vulnerabilities
  `);

  const exceptedRow = await db().queryOne<{ count: number }>(
    `SELECT COUNT(DISTINCT cve_id)::integer as count FROM harbor_vulnerability_exceptions WHERE is_active = true`,
  );

  return {
    total: row?.total ?? 0,
    critical: row?.critical ?? 0,
    high: row?.high ?? 0,
    medium: row?.medium ?? 0,
    low: row?.low ?? 0,
    in_use_total: row?.in_use_total ?? 0,
    in_use_critical: row?.in_use_critical ?? 0,
    fixable: row?.fixable ?? 0,
    excepted: exceptedRow?.count ?? 0,
  };
}

// ---------------------------------------------------------------------------
// Exception CRUD
// ---------------------------------------------------------------------------

export async function getExceptions(activeOnly = true): Promise<ExceptionRecord[]> {
  const where = activeOnly ? 'WHERE is_active = true' : '';
  return db().query<ExceptionRecord>(
    `SELECT * FROM harbor_vulnerability_exceptions ${where} ORDER BY created_at DESC`,
  );
}

export async function createException(data: {
  cve_id: string;
  scope?: string;
  scope_ref?: string;
  justification: string;
  created_by: string;
  expires_at?: string;
}): Promise<ExceptionRecord | null> {
  const scope = data.scope ?? 'global';
  const scopeRef = data.scope_ref ?? null;

  await db().execute(
    `INSERT INTO harbor_vulnerability_exceptions (cve_id, scope, scope_ref, justification, created_by, expires_at)
     VALUES (?, ?, ?, ?, ?, ?)
     ON CONFLICT(cve_id, scope, scope_ref) DO UPDATE SET
       justification = excluded.justification,
       is_active = true,
       expires_at = excluded.expires_at,
       updated_at = NOW()`,
    [data.cve_id, scope, scopeRef, data.justification, data.created_by, data.expires_at ?? null],
  );

  return db().queryOne<ExceptionRecord>(
    'SELECT * FROM harbor_vulnerability_exceptions WHERE cve_id = ? AND scope = ? AND scope_ref IS NOT DISTINCT FROM ?',
    [data.cve_id, scope, scopeRef],
  );
}

export async function deactivateException(id: number): Promise<boolean> {
  const result = await db().execute(
    'UPDATE harbor_vulnerability_exceptions SET is_active = false, updated_at = NOW() WHERE id = ?',
    [id],
  );
  return result.changes > 0;
}

// ---------------------------------------------------------------------------
// Sync status tracking
// ---------------------------------------------------------------------------

export async function createSyncStatus(syncType: string): Promise<number> {
  const row = await db().queryOne<{ id: number }>(
    `INSERT INTO harbor_sync_status (sync_type, status) VALUES (?, 'running') RETURNING id`,
    [syncType],
  );
  return row?.id ?? 0;
}

export async function completeSyncStatus(
  id: number,
  vulnsSynced: number,
  inUseMatched: number,
): Promise<void> {
  await db().execute(
    `UPDATE harbor_sync_status SET status = 'completed', vulnerabilities_synced = ?, in_use_matched = ?, completed_at = NOW() WHERE id = ?`,
    [vulnsSynced, inUseMatched, id],
  );
}

export async function failSyncStatus(id: number, errorMessage: string): Promise<void> {
  await db().execute(
    `UPDATE harbor_sync_status SET status = 'failed', error_message = ?, completed_at = NOW() WHERE id = ?`,
    [errorMessage, id],
  );
}

export async function getLatestSyncStatus(): Promise<SyncStatusRecord | null> {
  return db().queryOne<SyncStatusRecord>(
    'SELECT * FROM harbor_sync_status ORDER BY started_at DESC LIMIT 1',
  );
}

/** Remove old vulnerability records (retention) */
export async function cleanupOldVulnerabilities(retentionDays: number): Promise<number> {
  const result = await db().execute(
    `DELETE FROM harbor_vulnerabilities WHERE synced_at < NOW() - (? || ' days')::INTERVAL`,
    [`${retentionDays}`],
  );
  return result.changes;
}
