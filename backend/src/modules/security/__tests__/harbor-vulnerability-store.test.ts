import { beforeAll, afterAll, beforeEach, describe, it, expect, vi } from 'vitest';
import { getTestDb, truncateTestTables, closeTestDb } from '../../../core/db/test-db-helper.js';
import type { AppDb } from '../../../core/db/app-db.js';

let testDb: AppDb;

// Kept: app-db-router mock — redirects to test PostgreSQL instance
vi.mock('../../../core/db/app-db-router.js', () => ({
  getDbForDomain: () => testDb,
}));

import {
  getVulnerabilitySummary,
  getVulnerabilities,
  replaceAllVulnerabilities,
  createException,
  deactivateException,
  getExceptions,
  createSyncStatus,
  completeSyncStatus,
  failSyncStatus,
  getLatestSyncStatus,
  cleanupOldVulnerabilities,
  type VulnerabilityInsert,
} from '../services/harbor-vulnerability-store.js';

const makeVuln = (overrides: Partial<VulnerabilityInsert> = {}): VulnerabilityInsert => ({
  cve_id: 'CVE-2024-0001',
  severity: 'High',
  cvss_v3_score: 7.5,
  package: 'openssl',
  version: '1.1.1',
  fixed_version: '1.1.2',
  status: 'fixed',
  description: 'Test vulnerability',
  links: null,
  project_id: 1,
  repository_name: 'myproject/myapp',
  digest: 'sha256:abc123',
  tags: null,
  in_use: false,
  matching_containers: null,
  ...overrides,
});

beforeAll(async () => { testDb = await getTestDb(); });
afterAll(async () => { await closeTestDb(); });
beforeEach(async () => {
  await truncateTestTables('harbor_sync_status', 'harbor_vulnerability_exceptions', 'harbor_vulnerabilities');
});

describe('harbor-vulnerability-store', () => {
  describe('getVulnerabilitySummary', () => {
    it('returns zero counts when no data exists', async () => {
      const summary = await getVulnerabilitySummary();
      expect(summary.total).toBe(0);
      expect(summary.critical).toBe(0);
      expect(summary.excepted).toBe(0);
    });

    it('returns correct counts from database', async () => {
      await replaceAllVulnerabilities([
        makeVuln({ cve_id: 'CVE-A', severity: 'Critical', cvss_v3_score: 9.8, in_use: true }),
        makeVuln({ cve_id: 'CVE-B', severity: 'Critical', cvss_v3_score: 9.5, digest: 'sha256:b', in_use: false }),
        makeVuln({ cve_id: 'CVE-C', severity: 'High', cvss_v3_score: 7.5, digest: 'sha256:c', in_use: true }),
        makeVuln({ cve_id: 'CVE-D', severity: 'Medium', cvss_v3_score: 5.0, fixed_version: null, digest: 'sha256:d', in_use: false }),
      ]);
      await createException({ cve_id: 'CVE-X', justification: 'Not exploitable', created_by: 'admin' });
      await createException({ cve_id: 'CVE-Y', justification: 'Not exploitable', created_by: 'admin' });

      const summary = await getVulnerabilitySummary();
      expect(summary.total).toBe(4);
      expect(summary.critical).toBe(2);
      expect(summary.high).toBe(1);
      expect(summary.medium).toBe(1);
      expect(summary.low).toBe(0);
      expect(summary.in_use_total).toBe(2);
      expect(summary.in_use_critical).toBe(1);
      expect(summary.fixable).toBe(3); // CVE-A, CVE-B, CVE-C have fixed_version; CVE-D has null
      expect(summary.excepted).toBe(2);
    });
  });

  describe('getVulnerabilities', () => {
    beforeEach(async () => {
      await replaceAllVulnerabilities([
        makeVuln({ cve_id: 'CVE-CRIT', severity: 'Critical', cvss_v3_score: 9.8, digest: 'sha256:crit', in_use: true }),
        makeVuln({ cve_id: 'CVE-HIGH', severity: 'High', cvss_v3_score: 7.5, digest: 'sha256:high', in_use: false }),
        makeVuln({ cve_id: 'CVE-MED', severity: 'Medium', cvss_v3_score: 5.0, digest: 'sha256:med', in_use: false }),
      ]);
    });

    it('returns all vulnerabilities with no filter', async () => {
      const results = await getVulnerabilities();
      expect(results).toHaveLength(3);
    });

    it('filters by severity', async () => {
      const results = await getVulnerabilities({ severity: 'Critical' });
      expect(results).toHaveLength(1);
      expect(results[0].cve_id).toBe('CVE-CRIT');
    });

    it('filters by in-use status', async () => {
      const results = await getVulnerabilities({ inUse: true });
      expect(results).toHaveLength(1);
      expect(results[0].cve_id).toBe('CVE-CRIT');
    });

    it('orders by severity (Critical first)', async () => {
      const results = await getVulnerabilities();
      expect(results[0].severity).toBe('Critical');
      expect(results[1].severity).toBe('High');
      expect(results[2].severity).toBe('Medium');
    });
  });

  describe('replaceAllVulnerabilities', () => {
    it('inserts all provided vulnerabilities and returns count', async () => {
      const count = await replaceAllVulnerabilities([
        makeVuln({ cve_id: 'CVE-001' }),
        makeVuln({ cve_id: 'CVE-002', digest: 'sha256:002' }),
      ]);
      expect(count).toBe(2);
      const results = await getVulnerabilities();
      expect(results).toHaveLength(2);
    });

    it('replaces all previous vulnerabilities on subsequent call', async () => {
      await replaceAllVulnerabilities([makeVuln({ cve_id: 'CVE-OLD' })]);
      await replaceAllVulnerabilities([
        makeVuln({ cve_id: 'CVE-NEW-1' }),
        makeVuln({ cve_id: 'CVE-NEW-2', digest: 'sha256:new2' }),
      ]);
      const results = await getVulnerabilities();
      expect(results).toHaveLength(2);
      expect(results.some(v => v.cve_id === 'CVE-OLD')).toBe(false);
    });

    it('handles duplicate vulnerabilities within a batch without errors (#740)', async () => {
      const base = makeVuln({ cve_id: 'CVE-2024-9999', severity: 'High' });
      const duplicate = { ...base, severity: 'Critical' as const };
      // Two records with same (cve_id, package, version, digest) — second upserts over first
      const count = await replaceAllVulnerabilities([base, duplicate]);
      expect(count).toBe(2); // Processed 2
      const results = await getVulnerabilities({ cveId: 'CVE-2024-9999' });
      expect(results).toHaveLength(1); // But only 1 row in DB
      expect(results[0].severity).toBe('Critical'); // Last write wins
    });

    it('upserts on conflict — updates existing row instead of failing (#740)', async () => {
      await replaceAllVulnerabilities([makeVuln({ severity: 'High', cvss_v3_score: 7.5 })]);
      // Second replace with same unique key but different severity
      await replaceAllVulnerabilities([makeVuln({ severity: 'Critical', cvss_v3_score: 9.8 })]);
      const results = await getVulnerabilities();
      expect(results).toHaveLength(1);
      expect(results[0].severity).toBe('Critical');
    });
  });

  describe('exception management', () => {
    it('creates an exception with required fields', async () => {
      const exception = await createException({
        cve_id: 'CVE-2024-1234',
        justification: 'Not exploitable in our context',
        created_by: 'admin',
      });
      expect(exception).toBeTruthy();
      expect(exception?.cve_id).toBe('CVE-2024-1234');
      expect(exception?.scope).toBe('global');
      expect(exception?.is_active).toBe(true);
    });

    it('deactivates an exception by id', async () => {
      const exception = await createException({
        cve_id: 'CVE-2024-5678',
        justification: 'Will fix next sprint',
        created_by: 'admin',
      });

      const result = await deactivateException(exception!.id);
      expect(result).toBe(true);

      const active = await getExceptions();
      expect(active.some(e => e.id === exception!.id)).toBe(false);
    });

    it('returns false when exception not found', async () => {
      const result = await deactivateException(999999);
      expect(result).toBe(false);
    });

    it('lists active exceptions only by default', async () => {
      const ex1 = await createException({ cve_id: 'CVE-A', justification: 'Reason A', created_by: 'admin' });
      const ex2 = await createException({ cve_id: 'CVE-B', justification: 'Reason B', created_by: 'admin' });
      await deactivateException(ex2!.id);

      const active = await getExceptions();
      expect(active).toHaveLength(1);
      expect(active[0].cve_id).toBe('CVE-A');
    });

    it('lists all exceptions when activeOnly is false', async () => {
      const ex1 = await createException({ cve_id: 'CVE-A', justification: 'Reason A', created_by: 'admin' });
      const ex2 = await createException({ cve_id: 'CVE-B', justification: 'Reason B', created_by: 'admin' });
      await deactivateException(ex2!.id);

      const all = await getExceptions(false);
      expect(all).toHaveLength(2);
    });
  });

  describe('sync status tracking', () => {
    it('creates a running sync status and returns an id', async () => {
      const id = await createSyncStatus('full');
      expect(id).toBeGreaterThan(0);
    });

    it('completes a sync status with counts', async () => {
      const id = await createSyncStatus('full');
      await completeSyncStatus(id, 100, 20);
      const status = await getLatestSyncStatus();
      expect(status?.status).toBe('completed');
      expect(status?.vulnerabilities_synced).toBe(100);
      expect(status?.in_use_matched).toBe(20);
      expect(status?.completed_at).toBeTruthy();
    });

    it('fails a sync status with error message', async () => {
      const id = await createSyncStatus('incremental');
      await failSyncStatus(id, 'Connection refused');
      const status = await getLatestSyncStatus();
      expect(status?.status).toBe('failed');
      expect(status?.error_message).toBe('Connection refused');
    });

    it('gets the most recently started sync status', async () => {
      await createSyncStatus('full');
      const id2 = await createSyncStatus('incremental');
      await completeSyncStatus(id2, 50, 10);
      const status = await getLatestSyncStatus();
      expect(status?.id).toBe(id2);
      expect(status?.sync_type).toBe('incremental');
    });
  });

  describe('cleanup', () => {
    it('deletes old vulnerability records by retention days', async () => {
      // Insert a current vulnerability
      await replaceAllVulnerabilities([makeVuln({ cve_id: 'CVE-FRESH' })]);

      // Insert an old vulnerability directly with a backdated synced_at
      await testDb.execute(
        `INSERT INTO harbor_vulnerabilities
           (cve_id, severity, cvss_v3_score, package, version, fixed_version, status, description, links,
            project_id, repository_name, digest, tags, in_use, matching_containers, synced_at)
         VALUES ('CVE-OLD', 'Low', 4.0, 'oldpkg', '1.0.0', NULL, 'affected', 'Old vuln', NULL,
                 1, 'proj/app', 'sha256:oldone', NULL, false, NULL, NOW() - INTERVAL '40 days')`,
        [],
      );

      const deleted = await cleanupOldVulnerabilities(30);
      expect(deleted).toBe(1);

      const remaining = await getVulnerabilities();
      expect(remaining).toHaveLength(1);
      expect(remaining[0].cve_id).toBe('CVE-FRESH');
    });
  });
});
