import { describe, it, expect, vi, beforeEach } from 'vitest';

const mockDb = {
  execute: vi.fn().mockResolvedValue({ changes: 1 }),
  query: vi.fn().mockResolvedValue([]),
  queryOne: vi.fn().mockResolvedValue(null),
  transaction: vi.fn(async (fn: (db: unknown) => Promise<unknown>) => fn(mockDb)),
};

vi.mock('../db/app-db-router.js', () => ({
  getDbForDomain: vi.fn(() => mockDb),
}));

vi.mock('../utils/logger.js', () => ({
  createChildLogger: () => ({
    info: vi.fn(),
    error: vi.fn(),
    warn: vi.fn(),
    debug: vi.fn(),
  }),
}));

import {
  getVulnerabilitySummary,
  getVulnerabilities,
  replaceAllVulnerabilities,
  createException,
  deactivateException,
  getExceptions,
  createSyncStatus,
  completeSyncStatus,
  failSyncStatus,
  getLatestSyncStatus,
  cleanupOldVulnerabilities,
} from './harbor-vulnerability-store.js';

describe('harbor-vulnerability-store', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('getVulnerabilitySummary', () => {
    it('returns zero counts when no data exists', async () => {
      mockDb.queryOne
        .mockResolvedValueOnce(null)
        .mockResolvedValueOnce(null);

      const summary = await getVulnerabilitySummary();
      expect(summary.total).toBe(0);
      expect(summary.critical).toBe(0);
      expect(summary.excepted).toBe(0);
    });

    it('returns correct counts from database', async () => {
      mockDb.queryOne
        .mockResolvedValueOnce({
          total: 100, critical: 5, high: 15, medium: 30, low: 50,
          in_use_total: 20, in_use_critical: 3, fixable: 40,
        })
        .mockResolvedValueOnce({ count: 2 });

      const summary = await getVulnerabilitySummary();
      expect(summary).toEqual({
        total: 100, critical: 5, high: 15, medium: 30, low: 50,
        in_use_total: 20, in_use_critical: 3, fixable: 40, excepted: 2,
      });
    });
  });

  describe('getVulnerabilities', () => {
    it('queries with severity filter', async () => {
      await getVulnerabilities({ severity: 'Critical' });
      expect(mockDb.query).toHaveBeenCalledTimes(1);
      const sql = mockDb.query.mock.calls[0][0] as string;
      expect(sql).toContain('v.severity = ?');
    });

    it('queries with in-use filter', async () => {
      await getVulnerabilities({ inUse: true });
      const sql = mockDb.query.mock.calls[0][0] as string;
      expect(sql).toContain('v.in_use = ?');
    });

    it('queries with no filters', async () => {
      await getVulnerabilities();
      const sql = mockDb.query.mock.calls[0][0] as string;
      expect(sql).not.toContain('WHERE');
    });

    it('orders by severity then in-use then CVSS', async () => {
      await getVulnerabilities();
      const sql = mockDb.query.mock.calls[0][0] as string;
      expect(sql).toContain('ORDER BY');
      expect(sql).toContain("WHEN 'Critical' THEN 0");
      expect(sql).toContain('v.in_use DESC');
    });
  });

  describe('replaceAllVulnerabilities', () => {
    it('uses transaction and clears old data', async () => {
      const vulns = [
        {
          cve_id: 'CVE-2024-1234', severity: 'Critical', cvss_v3_score: 9.8,
          package: 'openssl', version: '1.1.1', fixed_version: '1.1.2',
          status: 'fixed', description: 'test', links: null,
          project_id: 1, repository_name: 'myproject/myapp', digest: 'sha256:abc',
          tags: '["latest"]', in_use: true, matching_containers: null,
        },
      ];

      const count = await replaceAllVulnerabilities(vulns);
      expect(count).toBe(1);
      expect(mockDb.transaction).toHaveBeenCalledTimes(1);

      // Should DELETE first then INSERT
      const executeCalls = mockDb.execute.mock.calls;
      expect(executeCalls[0][0]).toContain('DELETE FROM harbor_vulnerabilities');
      expect(executeCalls[1][0]).toContain('INSERT INTO harbor_vulnerabilities');
    });
  });

  describe('exception management', () => {
    it('creates an exception with required fields', async () => {
      mockDb.queryOne.mockResolvedValueOnce({
        id: 1, cve_id: 'CVE-2024-1234', scope: 'global',
        justification: 'Not exploitable in our context',
        created_by: 'admin', is_active: true,
      });

      const exception = await createException({
        cve_id: 'CVE-2024-1234',
        justification: 'Not exploitable in our context',
        created_by: 'admin',
      });

      expect(exception).toBeTruthy();
      expect(mockDb.execute).toHaveBeenCalledTimes(1);
      const sql = mockDb.execute.mock.calls[0][0] as string;
      expect(sql).toContain('INSERT INTO harbor_vulnerability_exceptions');
    });

    it('deactivates an exception by id', async () => {
      mockDb.execute.mockResolvedValueOnce({ changes: 1 });

      const result = await deactivateException(1);
      expect(result).toBe(true);
      const sql = mockDb.execute.mock.calls[0][0] as string;
      expect(sql).toContain('is_active = false');
    });

    it('returns false when exception not found', async () => {
      mockDb.execute.mockResolvedValueOnce({ changes: 0 });

      const result = await deactivateException(999);
      expect(result).toBe(false);
    });

    it('lists active exceptions only by default', async () => {
      await getExceptions();
      const sql = mockDb.query.mock.calls[0][0] as string;
      expect(sql).toContain('WHERE is_active = true');
    });

    it('lists all exceptions when activeOnly is false', async () => {
      await getExceptions(false);
      const sql = mockDb.query.mock.calls[0][0] as string;
      expect(sql).not.toContain('WHERE');
    });
  });

  describe('sync status tracking', () => {
    it('creates a running sync status', async () => {
      mockDb.queryOne.mockResolvedValueOnce({ id: 42 });

      const id = await createSyncStatus('full');
      expect(id).toBe(42);
      const sql = mockDb.queryOne.mock.calls[0][0] as string;
      expect(sql).toContain("'running'");
      expect(sql).toContain('RETURNING id');
    });

    it('completes a sync status', async () => {
      await completeSyncStatus(42, 100, 20);
      const sql = mockDb.execute.mock.calls[0][0] as string;
      expect(sql).toContain("'completed'");
    });

    it('fails a sync status with error message', async () => {
      await failSyncStatus(42, 'Connection refused');
      const sql = mockDb.execute.mock.calls[0][0] as string;
      expect(sql).toContain("'failed'");
    });

    it('gets latest sync status', async () => {
      mockDb.queryOne.mockResolvedValueOnce({ id: 1, status: 'completed' });

      const status = await getLatestSyncStatus();
      expect(status?.status).toBe('completed');
      const sql = mockDb.queryOne.mock.calls[0][0] as string;
      expect(sql).toContain('ORDER BY started_at DESC LIMIT 1');
    });
  });

  describe('cleanup', () => {
    it('deletes old vulnerability records by retention days', async () => {
      mockDb.execute.mockResolvedValueOnce({ changes: 50 });

      const deleted = await cleanupOldVulnerabilities(30);
      expect(deleted).toBe(50);
    });
  });
});
