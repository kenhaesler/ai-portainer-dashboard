# ADR-002: Harbor Registry Integration for Vulnerability Management

**Status:** Proposed
**Date:** 2026-02-16

## Context

The AI Portainer Dashboard currently monitors container security posture (capabilities, privileges, network modes) and image staleness, but has no integration with image vulnerability scanning. The organization uses Harbor Registry v2.14.2 with Trivy for vulnerability scanning. Teams need to:

- See which vulnerabilities exist in images currently deployed via Portainer
- Prioritize vulnerabilities in running containers over those in unused images
- Manage CVE exceptions with documented justifications and audit trails
- Get proactive alerts when critical vulnerabilities affect running workloads

## Decision Drivers

- Harbor v2.14.2 API provides comprehensive vulnerability data via Security Hub (`/security/summary`, `/security/vul`), per-artifact scans, and CVE allowlists
- Current architecture patterns (service + store + route + Socket.IO + page) are well-established and proven
- Exception management requires richer metadata than Harbor's native CVE allowlist (which only stores CVE IDs + expiry)
- Correlation between Harbor artifacts and Portainer containers is the key differentiator — knowing what's actually running

## Considered Options

### Option 1: Direct Harbor API Integration (Backend Service Only)
New `harbor-client.ts` backend service that directly calls Harbor's REST API with periodic sync, local PostgreSQL storage, and a new vulnerability management page. Full control over data model but introduces data duplication and sync lag.

### Option 2: Harbor as MCP Tool (LLM-Powered Analysis Only)
Add Harbor as another MCP server (like existing Grype/Snyk/NVD tools) so the LLM assistant can query vulnerabilities on demand. Fastest to implement but no persistent dashboard, no trend tracking, no auditable exception management.

### Option 3: Hybrid — Backend Sync + LLM Analysis + UI Management (Recommended)
Combine automated backend sync for continuous visibility with LLM-powered analysis for prioritization, plus a dedicated UI for exception management with full audit trail. Phased implementation allows incremental delivery.

### Option 4: Harbor Proxy with Portainer Enrichment
Thin proxy layer that passes through Harbor API calls but enriches responses with Portainer deployment context. Harbor remains sole source of truth. Simple but no offline resilience, no rich exception metadata, no trend data.

## Decision

Adopt **Option 3 (Hybrid)** with phased implementation:

- **Phase 1**: Harbor client service, vulnerability data sync, Portainer correlation engine, basic vulnerability page
- **Phase 2**: Exception management with documentation, audit trail, Harbor allowlist sync
- **Phase 3**: LLM assistant integration, Socket.IO real-time alerts, trend analysis

## Harbor v2.14.2 API Reference

### Key Endpoints

| Endpoint | Method | Purpose |
|---|---|---|
| `/api/v2.0/security/summary` | GET | System-wide vulnerability overview (counts + dangerous CVEs/artifacts) |
| `/api/v2.0/security/vul` | GET | Filterable vulnerability list (`q=severity=Critical`, etc.) |
| `/api/v2.0/system/CVEAllowlist` | GET/PUT | System-level CVE allowlist management |
| `/api/v2.0/projects` | GET | List all Harbor projects (includes embedded `cve_allowlist`) |
| `/api/v2.0/projects/{name}/repositories` | GET | List repositories per project |
| `/api/v2.0/projects/{name}/repositories/{repo}/artifacts` | GET | List artifacts with `?with_scan_overview=true&with_tag=true` |
| `/api/v2.0/projects/{name}/repositories/{repo}/artifacts/{ref}/additions/vulnerabilities` | GET | Detailed per-artifact vulnerability list |
| `/api/v2.0/projects/{name}/repositories/{repo}/artifacts/{ref}/scan` | POST | Trigger vulnerability scan (async, returns 202) |
| `/api/v2.0/system/scanAll/schedule` | GET/POST/PUT | Manage scheduled scan-all jobs |
| `/api/v2.0/export/cve` | POST | Trigger CSV export of scan data |

### Authentication
- Robot account with Basic Auth: `Authorization: Basic <base64(robot$name:secret)>`
- Robot accounts support granular permissions per resource/action
- Read-only access sufficient for monitoring; admin required for allowlist updates

### Key Data Models

```typescript
interface VulnerabilityItem {
  project_id: number;
  repository_name: string;
  digest: string;
  tags: string[];
  cve_id: string;
  severity: string;        // "Critical" | "High" | "Medium" | "Low" | "None" | "Unknown"
  status: string;          // "fixed" | "won't fix"
  cvss_v3_score: number;
  package: string;
  version: string;
  fixed_version: string;
  desc: string;
  links: string[];
}

interface SecuritySummary {
  critical_cnt: number;
  high_cnt: number;
  medium_cnt: number;
  low_cnt: number;
  none_cnt: number;
  unknown_cnt: number;
  total_vuls: number;
  scanned_cnt: number;
  total_artifact: number;
  fixable_cnt: number;
  dangerous_cves?: DangerousCVE[];
  dangerous_artifacts?: DangerousArtifact[];
}

interface CVEAllowlist {
  id?: number;
  project_id?: number;      // 0 = system-level
  expires_at?: number | null; // Unix epoch seconds, null = never
  items?: { cve_id: string }[];
  creation_time?: string;
  update_time?: string;
}
```

### Gotchas

- **Async scanning**: `POST .../scan` returns 202. Poll `with_scan_overview=true` for completion.
- **CVE allowlist no cascade**: Removing a CVE from system allowlist does NOT auto-remove from project allowlists.
- **Robot secret shown once**: Store immediately on creation.
- **tune_count for performance**: Set `tune_count=true` on `/security/vul` for large registries (avoids expensive COUNT).
- **Project-level allowlists**: Managed via `PUT /projects/{id}` (embedded `cve_allowlist` field), not a standalone endpoint.
- **`reuse_sys_cve_allowlist`**: Project metadata flag — when "true", project's own allowlist is ignored in favor of system list.

## Consequences

### Positive
- Comprehensive vulnerability visibility with in-use prioritization (running containers flagged first)
- Auditable exception management with required justifications, expiry, and reviewer tracking
- AI-assisted vulnerability analysis and exception documentation via existing LLM assistant
- Proactive Socket.IO alerting on critical vulnerabilities in running containers
- Follows established architectural patterns — predictable implementation

### Negative
- Data duplication between Harbor and PostgreSQL (mitigated by periodic sync with configurable interval)
- Larger implementation scope (~3 weeks across all phases)
- Need to maintain Harbor API compatibility (pinned to v2.14.2, monitor for breaking changes)

### Neutral
- Requires Harbor robot account configuration (one-time setup)
- Adds `HARBOR_API_URL`, `HARBOR_ROBOT_NAME`, `HARBOR_ROBOT_SECRET` environment variables
- Existing security-scanner.ts (capability posture) and image-staleness.ts remain independent — this is additive

## Related

- ADR-001: SQLite to PostgreSQL Migration
- Existing services: `security-scanner.ts`, `security-audit.ts`, `image-staleness.ts`
- Existing MCP tools: `tools/grype-mcp`, `tools/snyk-mcp`, `tools/nvd-mcp`
- Harbor API v2.0 Swagger: https://github.com/goharbor/harbor/blob/v2.14.2/api/v2.0/swagger.yaml
- Harbor Security Hub docs: https://goharbor.io/docs/main/administration/security-hub/
